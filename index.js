// Generated by LiveScript 1.2.0
(function(){
  var EE, timestamp, through, hat, Live, Pointer;
  EE = require('events').EventEmitter;
  timestamp = require('monotonic-timestamp');
  through = require('through2');
  hat = require('hat');
  Live = (function(superclass){
    var prototype = extend$((import$(Live, superclass).displayName = 'Live', Live), superclass).prototype, constructor = Live;
    function Live(){
      this.id = hat();
      this.sources = {};
    }
    prototype.registered = function(db){
      return this.emit('registered', db);
    };
    prototype.get = function(key){
      if (key != null) {
        return new Live.Pointer(this, key);
      } else {
        return this._get();
      }
    };
    prototype.set = function(key, val){
      if (arguments.length >= 2) {
        return this._setKey(key, val);
      } else if (arguments.length >= 1) {
        return this._set(key);
      } else {
        throw new Error(this.constructor.name + "" + set + " takes 1 or 2 arguments");
      }
    };
    prototype.bind = function(other, opts){
      var aOpts, bOpts, k, v, m;
      opts == null && (opts = {});
      aOpts = {};
      bOpts = {};
      for (k in opts) {
        v = opts[k];
        m = k.match(/^reverse([A-Z])([\s\S]*)/);
        if (m) {
          bOpts[m[1].toLowerCase() + m[2]] = v;
        } else {
          aOpts[k] = v;
        }
      }
      return this.pipe(other, aOpts).pipe(this, bOpts);
    };
    prototype._pipeStream = function(opts){
      return through.obj(function(u, arg$, done){
        this.push(u);
        return done();
      });
    };
    prototype.pipe = function(dest, opts){
      var stream, i$, ref$, len$, u;
      opts == null && (opts = {});
      stream = this._pipeStream(opts);
      if (opts.initial == null) {
        opts.initial = true;
      }
      this.on('_update', function(u){
        return stream.write(u);
      });
      if (opts.initial) {
        for (i$ = 0, len$ = (ref$ = this.history()).length; i$ < len$; ++i$) {
          u = ref$[i$];
          if (typeof u === 'object') {
            stream.write(u);
          }
        }
      }
      stream.on('data', function(u){
        return dest._update(u);
      });
      return dest;
    };
    prototype._update = function(u){
      if (this.sources[u.source] == null || u.time > this.sources[u.source]) {
        this.sources[u.source] = u.time;
        if (this._applyUpdate(u)) {
          return this.emit('_update', u);
        }
      }
    };
    prototype._localUpdate = function(data){
      return this._update({
        source: this.id,
        time: timestamp(),
        data: data
      });
    };
    Live.get = function(store, key){
      if (store instanceof Live) {
        if (key != null) {
          return store._getKey(key);
        } else {
          return store._get();
        }
      } else {
        if (key != null) {
          return store[key];
        } else {
          return store;
        }
      }
    };
    Live.set = function(store, key, val){
      if (store instanceof Live) {
        if (arguments.length >= 3) {
          return store._setKey(key, val);
        } else {
          return store._set(key);
        }
      } else {
        if (arguments.length >= 3) {
          return store[key] = val;
        } else {
          throw new Error('Cannot set a non-wrapped object');
        }
      }
    };
    return Live;
  }(EE));
  Live.Pointer = Pointer = (function(superclass){
    var prototype = extend$((import$(Pointer, superclass).displayName = 'Pointer', Pointer), superclass).prototype, constructor = Pointer;
    function Pointer(kv, key){
      var this$ = this;
      this.kv = kv;
      this.key = key;
      this.on('newListener', function(name, fn){
        if (name === 'val') {
          return fn(this$.get());
        }
      });
      if (this.kv instanceof Live) {
        this.kv.on("prechange:" + this.key, function(newVal, oldVal){
          return this$.emit('prechange', newVal, oldVal);
        });
        this.kv.on("changed:" + this.key, function(newVal, oldVal){
          return this$.emit('changed', newVal, oldVal);
        });
        this.kv.on("val:" + this.key, function(newVal, oldVal){
          return this$.emit('val', newVal, oldVal);
        });
      }
    }
    prototype._set = function(newVal){
      return Live.set(this.kv, this.key, newVal);
    };
    prototype._get = function(){
      return Live.get(this.kv, this.key);
    };
    return Pointer;
  }(Live));
  module.exports = Live;
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
